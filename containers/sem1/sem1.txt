Вызов ченчрут на практике
Для этого создаим каталог ГБ в домашнем каталоге пользователя
и запустить команду ченж рут

Первое что делаем, создадим деректорию
mkdir testfolder

chroot testfolder /bin/bash
1 — ый аргумент testfolder — название папки
которую мы хотим сделать корневой
2 — ой /bin/bash комндный интерпретатор
который мы хотим использовать
chroot: failed to run command ‘/bin/bash’:
No such file or directory
Ошибка — не найдена командная оболочка
В нашем случае применяя команду мы создаем абсолютно новую изолированную файловую систему, которая при этом не имеет доступа к системной, которая содержится выше нового корня и не содержит ничего на данный момент.
В данном случае обращение к бин.баш процесс будет выполнять через следующий путь это testfolder.бин.баш. А как мы можем посмотреть
ls testfolder … папка директория абсолютно пуста

Для того чтобы все запустилось корректно, надо изменить набор команд, для этого необходимо создать в новом корне папку бин.
mkdir testfolder/bin

И поместить туда исполняемый файл командного интерпретатора
cp /bin/bash testfolder/bin

И можем попробовать повторить нашу команду
chroot testfolder /bin/bash
chroot: failed to run command ‘/bin/bash’: 
No such file or directory
Казалось бы мы скопировали в исполнительную файловую систему исполняемый файл. 
Однако ошибка осталась, несмотря на то что текст ошибки выглядит точно та же , в данном случае расшифровка совсем другая.
Теперь сам исполняемый файл присутствует и доступен.
Проблема в том, что нам не хватает необходимых библиотек для запуска исполняемого файла.
Вопрос. Что сделат для решения этой проблемы ?
Ответ. Необходимо скопировать весь набор библеотек так же в ЧенчРут папку.
Вопрос. Как можно узнать какие библиотеки(Зависимости) необходимо скопировать.
Ответ. Воспользоваться следующей командой, которая позволит нам отобразить необходимые зависимости.

ldd /bin/bash
Все эти файлы необходимо скопировать, но прежде чем мы скопируем , необходимо создать необходимые директорию. Директорию либ или либ_64

mkdir testfolder/lib
mkdir testfolder/lib64

cp /lib/x86_64-linux-gnu/libtinfo.so.6 testfolder/lib
cp /lib/x86_64-linux-gnu/libc.so.6 testfolder/lib
cp /lib64/ld-linux-x86-64.so.2 testfolder/lib64/

Теперь можно попытаться сделать смену корня
chroot testfolder
Сейчас все получилось. Можно увидеть что приветствие системы изменилось.
Мы сменили в данном случае корневую папку , это по сути означает что мы изолировали процесс. По сути у Нас запустилась изолированная оболочка интерпретатора БАШ, с корнем отличным от файловой системы.
Теперь когда все получилось можно посмотреть текущую директорию с помощью команды

ls
bash: ls: command not found
однако есть проблема, программа не найдена
Вопрос. Почему получили эту ошибку.
Ответ довольно прост, как и ранее необходимо скопировать все необходимые исполняемые файлы в созданную папку вместе с динамическими библиотеками, как было показано раньше.

new addition
cp /bin/ls testfolder/bin/
ldd /bin/ls
cp /lib/x86_64-linux-gnu/libselinux.so.1 testfolder/lib/
cp /lib/x86_64-linux-gnu/libpcre2-8.so.0 testfolder/lib/
chroot testfolder/
ls /

Рассмотрев часть на практике , можно определить серьезный недостаток использования ЧенчжРут — При создании новой корневой директории , необходимо дублировать абсолютно все исполняемые файлы, что несомненно повлечет за собой рост заманиваемого дискового пространства.

Перейдем к Механизму пространства имен, так как он лишен этих проблем.
Пространство имен в системе Линукс, абстракция в которой находятся все системные ресурсы. Тип ресурса зависит от типа пространства имен. Пространство имен это не дополнительная функция которую можно установить или обойтись без нее. Это сущность которая изначально предоставляется самим ядром ОС и является необходимым компонентом, который принимает участие в процедуре запуска абсолютно любого процесса в системе. И в любой момент времени, любой процесс может принадлежать только одному пространству имен каждого типа. Так же Пространство имен это механизм который обеспечивает изоляцию процессов друг от друга в Юникс Системемах.

ls -l /proc/$$/ns

UID, например, позволяет каждому процессу получить привилегии
суперпользователя (root) в пределах определенного пространства имен. В этом
случае можно отдать процессу не глобальный неограниченный доступ ко всему, а
изолированный.
UTS - его мы можем использовать для изоляции различных системных
идентификаторов, таких как: имя узла (hostname), доменное имя (domainname). Все
они возвращаются встроенным системным вызовом uname().
uname - это инструмент, используемый для определения архитектуры
процессора, hostname, domainname, версии ядра системы и многих других
параметров. Вызывать его необходимо с набором параметров:

ip a

Сетевое пространство имен. Самый простой вариант
ip netns list
ip netns add testns — создали
команда — аргумент — команда - название
ip — это утилита которая в целом позволяет работать с сетью в системе.
Создаем пространство имен в ней
ip netns list — посмотрели
testns — увидели и еще формально ничего не подключенно
Это уже не папка в почти как Свитч — это такое устройство, которое формирует сеть, и в которое подключаются наши машинки через порты. Задача свитча L2 (есть ещё более продвинутые, относящиеся к L3 и даже к L7) — перенаправлять кадры от MAC отправителя к MAC получателя. Множество машин, подключенных к одному свитчу формируют локальную сеть (LAN).
Ip — просмотр команд
ip netns help — просмотр команд

Но пока пустой, когда выполняем эту команду
ip netns exec testns bash -
подключи такому свичу такой процесс
вот баш(программный интерпретатор) я хочу с ним поработать так, чтобы он был изолирован.
Ip a
Формально к нашему комутатору подключаеться ноутбук
Мы можем посмотреть только выдалось нам что то или нет, так как по факту там ничего нет потому что у нас нет дспчСервера который бы что то выдал ну и вообще ничего нет.
При этом мы остаемся в своей хостовой системе
ps aux
Он выведет абсолютно все
ip a
Но мы изолированы именно в сетевом пространстве имен
Как пример, в теории так мы могли изолировать подключение к устройству

Как проверить где мы?
ip netns exec testns bash -
Когда мы это сказали, он нас отправил в этот НеймСпейс

аналог нашего АйПи для пространства имен
unshare —net /bin/bash
ip a
мы сейчас в пространсве имен, который ограничен только по сетевому пространству
ps aux
мы ввели ps aux и весь набор процессов

теперь выйдем от сюда,и ограничим дополнительно.
unshare --net --pid --fork --mount-proc /bin/bash
ps aux
unshare Утилита которая позволяет это разграничивать -
--net — ограничевает сетевое пространство имен
ip a
-mount-proc — разграничивает процессы
ps aux
--fork — изолирует память
--pid — изолирует дерево процессов

Формально мы внутри контейнера
ls
ls /

ps aux